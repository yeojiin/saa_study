### Amazon RDS 개요
- RDS는 '관계형 데이터베이스 서비스'의 약자
- SQL을 쿼리 언어로 사용하는 데이터베이스용 관리형 데이터베이스 서비스
- AWS가 관리하는 DB 엔진의 유형에는 PostgreSQL, MySQL, MariaDB, Oracle Microsoft SQL Server, Aurora가 있음
- 데이터베이스 프로비저닝과 기본 운영체제 패치가 완전 자동화되어 있음
- 지속적으로 백업이 생성되므로 특정 타임스탬프, 즉 특정 시점으로 복원 가능
- 데이터베이스의 성능을 대시보드에서 모니터링할 수 있고, 읽기 전용 복제본을 활용해 읽기 성능을 개선할 수 있음
- 재해 복구 목적으로 다중 AZ를 설정할 수 있음
- 유지 관리 기간에 업그레이드를 할 수 있음
- 인스턴스 유형을 늘려 수직 확장하거나 읽기 전용 복제본을 추가하여 수평 확장할 수 있음
- 파일 스토리지는 EBS에 구성됨 -> gp2과 io1 볼륨이 있음(EBS 볼륨)
- 단점은 `RDS 인스턴스에 SSH 액세스할 수 없음`
- 관리형 서비스이므로 AWS가 서비스를 제공하지만 기본 EC2 인스턴스에는 액세스할 수 없음
- RDS 스토리지 오토 스케일링
	- RDS 데이터베이스를 만들 때 설정한 스토리지 용량이 부족할 경우 RDS 스토리지 오토 스케일링 기능이 활성화되어 있으면 RDS가 이를 감지해서 자동으로 스토리지 확장
	- 애플리케이션이 RDS 데이터베이스에서 읽기와 쓰기 작업을 많이 하면 임곗값에 도달하게 되고 RDS가 자동으로 스토리지를 오토 스케일링 -> 이를 위해 최대 스토리지 임곗값을 설정해야 하는데 스토리지를 확장할 최대치를 정하는 것
	- 워크로드를 예측할 수 없는 애플리케이션에서 유용, 모든 RDS 데이터베이스 엔진에서 지원되는 기능
	- MariaDB, MySQL PostgreSQL, SQL Server, Oracle에서 지원
### RDS 읽기 전용 복제본과 다중 AZ
- 읽기 전용 복제본(RDS Read Replicas)
- 읽기를 스케일링
- 애플리케이션과 RDS 데이터베이스 인스턴스가 있을 때 애플리케이션은 데이터베이스 인스턴스에 대해 읽기와 쓰기를 수행하지만 하지만 주된 데이터베이스 인스턴스가 너무 많은 요청을 받아서 충분히 스케일링할 수가 없어 읽기를 스케일링 필요
- 읽기 전용 복제본을 최대 `15개까지` 생성 가능
- 동일한 가용 영역 또는 가용 영역이나 리전을 걸쳐서 생성될 수 있음
- 두 개의 RDS 인스턴스 읽기 전용 복제본이 있다고 가정, 주된 RDS 데이터베이스 인스턴스와 두 읽기 전용 복제본 사이에 `비동기식(ASYNC) 복제가 발생` -> 읽기가 `일관적`으로 유지됨
- 복제본 중 하나를 DB로 사용하고 싶으면 권한을 획득하면 사용 가능
	- 복제 메커니즘을 버리고, 자체적인 생애 주기를 갖음
- 예시
	- 평균적인 로드를 감당하고 있는 프로덕션 데이터베이스가 있다고 가정, 프로덕션 데이터베이스에서는 메인 RDS 데이터베이스 인스턴스에 대한 읽기 및 쓰기가 수행
	- 이때 새로운 팀이 와서 여러분의 데이터를 기반으로 몇 가지 보고와 분석을 실시
	- 보고 애플리케이션을 메인 RDS 데이터베이스 인스턴스에 연결하면 오버로드가 발생 -> 새로운 워크로드에 대한 읽기 전용 복제본을 생성
	- 읽기 전용 복제본을 생성하면 메인 RDS DB 데이터베이스 인스턴스와 읽기 전용 복제본 간 비동기식 복제가 발생
	- 보고 애플리케이션이 생성한 읽기 전용 복제본에서 읽기 작업과 분석을 실행, 상용 어플리케이션은 영향을 받지 않음
	- **읽기 전용 복제본이 있는 경우에는 SELECT 명령문에만 사용**
- RDS 읽기 전용 복제본과 관련된 네트워킹 비용
	- AWS에서는 하나의 가용 영역에서 다른 가용 영역으로 데이터가 이동할 때에 비용이 발생
	- 하지만 예외가 존재하며 이 예외는 보통 관리형 서비스에서 발생
	- RDS 읽기 전용 복제본은 관리형 서비스로 읽기 전용 복제본이 다른 AZ 상이지만 동일한 리전 내에 있을 때는 비용이 발생하지 않음
	- 즉 us-east-1a에 RDS DB 인스턴스가 있고, 그에 대한 읽기 전용 복제본은 us-east-1b에 있을 때 이는 비동기식 복제로 읽기 전용 복제본의 복제 트래픽이 하나의 AZ에서 다른 AZ로 넘어가더라도 RDS가 관리형 서비스이기 때문에 해당 트래픽은 비용 없이 무료로 이동 가능
	- 하지만 서로 다른 리전에 복제본이 존재하는 경우 비용 발생
-  RDS 다중 AZ
	- 다중 AZ는 주로 재해 복구에 사용
	- 애플리케이션은 가용 영역 AZ A에서 읽기와 쓰기를 수행하는 마스터 데이터베이스 인스턴스라고 가정 그리고 동기식으로 이를 AZ B에 스탠바이 인스턴스로 복제
	- 마스터 데이터베이스의 모든 변화를 동기적으로 복제하는 것인데 이는 애플리케이션의 마스터에 쓰이는 변경 사항이 대기 인스턴스에도 그대로 복제된다는 것을 의미
	- 즉 하나의 DNS 이름을 갖고, 애플리케이션 또한 하나의 DNS 이름으로 통신하며 마스터에 문제가 생길 때에도 스탠바이 데이터베이스에 자동으로 장애 조치가 수행
	- 가용성을 높일 수 있음
	- 전체 AZ 또는 네트워크가 손실될 때에 대비한 장애 조치이자 마스터 데이터베이스의 인스턴스 또는 스토리지에 장애가 발생할 때 스탠바이 데이터베이스가 새로운 마스터가 될 수 있도록 하는 것
	- 자동으로 데이터베이스에 연결이 시도되고 장애 조치가 필요하게 될 때에도 스탠바이가 마스터로 승격되는 과정이 자동으로 이루어짐
	- 재해 복구를 대비해서 읽기 전용 복제본을 다중 AZ로 설정할 수 있을까?
		- 가능, 원하는 경우에는 읽기 전용 복제본을 다중 AZ로도 설정할 수 있음
- 단일 AZ에서 다중 AZ로 RDS 데이터베이스 전환이 가능한가?
	- 다운타임이 전혀 없음. 즉 단일 AZ에서 다중 AZ로 전환할 때에 데이터베이스를 중지할 필요가 없음
	- 기본 데이터베이스의 RDS가 자동으로 스냅샷을 생성, 이 스냅샷은 새로운 스탠바이 데이터베이스에 복원됨. 스탠바이 데이터베이스가 복원되면 두 데이터베이스 간 동기화가 설정되므로 스탠바이 데이터베이스가 메인 RDS 데이터베이스 내용을 모두 수용하여 다중 AZ 설정 상태가 됨
### RDS Custom for Oracle과 Microsoft SQL Server
- RDS에서는 기저 운영 체제나 사용자 지정 기능에 액세스할 수 없음 -> 그러나 RDS Custom에서는 가능
- RDS Custom은 두 유형의 데이터베이스를 다루는데 Oracle과 Microsoft SQL Server 
- 이 둘에서 OS 및 데이터베이스 사용자 지정 기능에 액세스할 수 있음
- RDS를 통해 AWS에서의 데이터베이스 자동화 설정, 운영, 스케일링의 장점을 이용할 수 있음
- RDS Custom 옵션을 추가하면기저 데이터베이스와 운영 체제에 액세스할 수 있게 됨
- 내부 설정 구성, 패치 적용 그리고 네이티브 기능 활성화가 가능하며 SSH 또는 SSM 세션 관리자를 사용해서 RDS 뒤에 있는 기저 EC2 인스턴스에 액세스할 수 있음
- 사용자 지정 설정을 사용하려면 RDS가 수시로 자동화, 유지 관리, 스케일링과 같은 작업을 수행하지 않도록 자동화를 꺼두는 것이 좋고, 스냅샷을 만들어 두는 것이 좋음 -> 복구에 용이
- RDS vs RDS Custom
	- RDS는 데이터베이스 전체를 관리
	- 운영 체제와 나머지는 AWS에서 관리하고 사용자는 아무것도 하지 않아도 됨
	- RDS Custom은 Oracle 및 Microsoft SQL Server에서만 사용할 수 있음
	- 그리고 기저 운영 체제와 데이터베이스에 대한 관리자 권한 전체를 갖게 됨
### Amazon Aurora 개요
- Aurora는 AWS 고유의 기술
- 오픈 소스는 아니지만 Postgres 및 MySQL과 호환
- Aurora 데이터베이스에 호환 가능한 드라이버가 있는데 Postgres 및 MySQL 데이터베이스에 연결하면 작동함을 의미
- 클라우드에 최적화되어 있고 RDS의 MySQL보다 5배 높은 성능이고, RDS의 Psostgres보다는 3배 높은 성능
- Aurora의 스토리지는 자동으로 확장
- DB나 SysOps로써 저장 디스크를 신경 쓰지 않아도 됨
- 읽기 전용 복제본의 경우 15개의 복제본을 둘 수 있음
- MySQL에서는 5개만 가능
- 복제 속도도 훨씬 빠름
- Aurora의 장애 조치는 즉각적 -> 따라서 다중 AZ나 MySQL RDS보다 훨씬 빠름
- 클라우드 네이티브이므로 가용성이 높음
- 비용은 RDS에 비해 약 20% 정도 높지만 스케일링 측면에서 훨씬 더 효율적
- 높은 가용성과 읽기 스케일링
- Aurora는 특이하게도 여러분이 세 AZ에 걸쳐 무언가를 기록할 때마다 6개의 사본을 저장
- Aurora는 가용성이 높으며 쓰기에는 6개 사본 중 4개만 있으면 됨 -> AZ 하나가 작동하지 않아도 괜찮음
- 일부 데이터가 손상되거나 문제가 있으면 백엔드에서 P2P 복제를 통한 자가 복구가 진행됨
- 단일 볼륨에 의존하지 않고 수 백 개의 볼륨을 사용
- Aurora는 RDS의 다중 AZ와 유사
- 쓰기를 받는 인스턴스는 하나 뿐임. 따라서 Aurora에도 마스터가 존재하고 여기서 쓰기를 받게 됨
- 그리고 마스터가 작동하지 않으면 평균 30초 이내로 장애 조치가 시작됨
- 마스터 외에 읽기를 제공하는 읽기 전용 복제본을 15개까지 둘 수 있음
- 복제본을 많이 두고 읽기 워크로드를 스케일링할 수 있음
- 마스터에 문제가 생기면 읽기 전용 복제본 중 하나가 마스터가 되어 대체
- 복제본들은 리전 간 복제를 지원
- 마스터는 하나고, 복제본은 여럿이며 스토리지가 복제되고 작은 블록 단위로 자가 복구 또는 확장이 일어남
- 클러스터로써 Aurora
	- 클라이언트가 있을 때 수많은 인스턴스와 어떻게 접속할까?
	- 공유 볼륨은 10GB에서 128TB까지 자동으로 확장됨
	- 스토리지에 쓰는 것은 마스터만이 가능
	- 마스터가 바뀌거나 장애 조치가 실행될 수 있으므로 Aurora에서는 라이터(Writer) 엔드포인트를 제공
	- 라이터 엔드포인트는 DNS 이름으로 항상 마스터를 가리킴
	- 따라서 장애 조치 후에도 클라이언트는 라이터 엔드포인트와 상호작용하게 되며 올바른 인스턴스로 자동으로 리다이렉트됨
	- 다수의 읽기 전용 복제본이 있는데 이 복제본에 대한 자동 스케일링이 가능
	- 읽기 전용 복제본을 15개까지 생성 가능하며 자동 스케일링을 설정해서 항상 적절한 수의 읽기 전용 복제본이 존재하도록 할 수 있음
	- 자동 스케일링이 켜져 있는 경우 여러분의 앱 입장에서는 복제본이 어디에 있고, URL은 무엇이고 어떻게 연결하는지 파악하기 어려울 때? 
		- 리더(Reader) 엔드포인트
		- 리더 엔드포인트는 라이터 엔드포인트와 정확히 같은 기능
		- 연결 로드 밸런싱에 도움을 줌
		- 모든 읽기 전용 복제본과 자동으로 연결
		- 클라이언트가 리더 엔드포인트에 연결될 때마다 읽기 전용 복제본 중 하나로 연결되며 이런 방식으로 로드 밸런싱을 도와줌
		- **로드 밸런싱이 문장 레벨이 아닌 연결 레벨에서 일어남**
		- Aurora가 작동하는 방법에 대해 알아봤습니다
- 백트랙
	- 과거 어떤 시점의 데이터로도 복원할 수 있게 해줌
	- 백업에 의존하지 않으며 다른 방법을 사용
	- 오후 4시 상태 돌아가고 싶다고 했다가 다시 생각해 보니 어제 오후 5시 상태로 돌아가고 싶다고 해도 가능하다는 뜻입니다 매우 유용한 기능
### Amazon Aurora - 고급개념
- Cluster storage configuration에서는 두 가지 옵션이 있음
	- Aurora Standard -> 많이 쓰지 않는 업무
	- I/O-optimized -> 오로라 데이터베이스에서 높은 입출력 연산과 읽기 및 쓰기 작업이 일어난다면 I/O-optimized가 좋을 수 있지만, 비용 효율이 높음
- 복제본 Auto Scaling
	- 클라이언트가 있고, 우리에게 세 개의 Aurora 인스턴스가 있는 상황을 가정
	- 한 개는 라이터 엔드포인트로 쓰고 있고, 나머지 두 개는 리더 엔드포인트로 읽고 있음
	- 리더 엔드포인트에 아주 많은 읽기 요청이 들어오고 있다고 가정 -> Amazon Aurora 데이터베이스의 CPU 사용량이 증가
	- 복제본 Auto Scaling을 설정할 수 있는데 Amazon Aurora 복제본들을 추가하는 것
	- 자동적으로 리더 엔드포인트는 새로운 레플리카들을 위해 확장됨
	- 새 레플리카들은 트래픽을 받기 시작할 것이고, 읽기는 더 많이 분배되는 방식으로 일어남 -> 전체적인 CPU 사용량을 낮출 수 있음
- 사용자 지정 엔드포인트
	- 위와 같은 상황에서, 이번에는 두 종류의 복제본이 있다고 가정
	- db.r3.large와 db.r5.2xlarge가 있을 때 어떤 읽기 전용 복제본은 다른 것보다 큰 상태
	- Aurora 인스턴스의 부분집합을 사용자지정 엔드포인트로 정의하기 위해서 사용
	- 두 개의 큰 Aurora 인스턴스에 사용자 지정 엔드포인트를 정의한다고 가정
	- 예를 들어 이 인스턴스들이 더 강력하기 때문에 저 특정 복제본들이 분석적 쿼리를 담당하는 게 나을 것이기 때문
	- 정의된 사용자 지정 엔드포인트가 생김
	- 일반적으로 사용자 지정 엔드포인트를 갖게 되면 사용자 지정 엔드포인트 정의 이후에는 리더 엔드포인트 자체는 사용되지 않게 됨
	- 각각의 다양한 업무마다 다양한 사용자 지정 엔드포인트를 만들어야 함
- 서버리스
	- 자동화된 데이터베이스 예시화와 실제 사용량에 따른 Auto Scaling을 제공
	- 간헐적이고 예측 불가능한 업무량에 대응하기 유용
	- capacity planning을 할 필요가 없게 됨
	- 활용하고 있는 Aurora 인스턴스마다 초당 비용 지불을 하는 것이 훨씬 비용 효율적
	- 클라이언트는 Aurora가 관리하는 프록시 플릿에 연락함, 그리고 백엔드에는 많은 Aurora 인스턴스들이 생성됨
	- 업무량에 기반해 서버리스 방식으로 되는데, 이로 인해 미리 용량을 준비하지 않아도 됨
- 글로벌 Aurora
	- Aurora 교차 리전 읽기 전용 복제본은 재해 복구에 도움이 많이 되고, 실행하기 간단
	- 모든 읽기와 쓰기가 일어나는 하나의 기본 리전이 있고, 최대 5개의 보조 읽기 전용 리전을 만들 수 있는데 이는 응답 지연이 1초 이하
	- 보조 리전 당 최대 16개의 읽기 전용 복제본을 사용할 수 있음
	- 전 세계에서 오는 읽기 업무량에 따른 대기 시간을 줄이는 데 유용
	- 한 리전에 데이터베이스 중단이 일어날 경우 재해 복구를 위해 다른 리전을 진급시키는데 다른 리전으로 들어가 복구시키는 시간이 1분 이내
	- **평균적으로 Aurora 글로벌 데이터베이스에서 한 리전에서 다른 리전으로 데이터를 복제하는 데에는 1초 이하의 시간이 걸림**
	- 예시
		- us-east-1을 기본 리전으로 사용. 응용프로그램이 읽기와 쓰기를 하는 곳
		- 그리고 eu-west-1에 보조 리전을 만들고 Aurora의 글로벌 데이터베이스와 함께 데이터 복제가 일어나고 응용프로그램은 읽기만 가능함
		- 만약 us-east-1이 중단되면, eu-west-1으로 failover(장애 조치)를 함 -> 읽기-쓰기 Aurora 클러스터로 진급
- Aurora는 AWS 안에 있는 기계 학습 서비스와 통합하기도 함
	- SQL 인터페이스를 통해 응용프로그램에 기계 학습 기반의 예측을 추가할 수 있다는 것
	- 두 가지 지원되는 서비스
		- SageMaker로 백엔드인 어떤 종류의 기계 학습 모델이라도 사용할 수 있게 허용
		- Amazon Comprehend는 감정 분석을 할 때 사용하면 됨
- Aurora 기계 학습을 사용하기 위해 기계 학습 경험이 필요하진 않고, 사용 사례는 이상 행위 탐지, 광고 타겟팅, 감정 분석, 상품 추천 등, 모두 Aurora 안에 있음
- Aurora는 AWS 안의 기계 학습 서비스에 응용프로그램은 간단한 SQL 쿼리만 실행할 수 있음
- 예를 들어, '추천 상품은 무엇인가?' 같은
- Aurora가 기계 학습 서비스로 데이터를 보내게 되는데 예를 들어, 사용자의 프로필, 구매 이력 등등 그러면 기계 학습 서비스는 Aurora에게 직접적으로 예측을 보냄
- 예를 들어, 사용자는 빨간 셔츠와 파란 바지를 구매해야 한다 처럼
- 그러면 Aurora는 쿼리 결과를 응용프로그램으로 반환하면 됨
### RDS Security
- RDS 및 Aurora 데이터베이스에 저장된 데이터를 암호화할 수 있음
	- 데이터가 볼륨에 암호화된다는 뜻
	- KMS를 사용해 마스터와 모든 복제본의 암호화가 이루어지며 이는 데이터베이스를 처음 실행할 때 정의
	- 마스터 즉 주 데이터베이스를 암호화하지 않았다면 읽기 전용 복제본을 암호화할 수 없음
	- 암호화 되어있지 않은 기존 데이터베이스를 암호화 하려면 암호화 되지 않은 데이터베이스의 데이터베이스 **스냅샷을 가지고 와서** 암호화된 데이터베이스 형태로 데이터베이스 스냅샷을 복원해야 함
- 클라이언트와 데이터베이스 간의 전송 중 데이터 암호화
	- RDS 및 Aurora의 각 데이터베이스는 기본적으로 `전송 중 데이터 암호화` 기능을 갖추고 있음
	- 클라이언트는 AWS 웹사이트에서 제공하는 AWS의 TLS 루트 인증서를 사용해야 함
	- RDS와 Aurora이므로 사용자 이름과 패스워드라는 전통적인 조합을 사용할 수도 있음
	- IAM 역할을 사용해서 데이터베이스에 접속할 수도 있음
	- 예를 들어 EC2 인스턴스에 IAM 역할이 있다면 이를 사용해 사용자 이름이나 패스워드 없이 직접 데이터베이스를 인증할 수 있음
- 보안 그룹을 사용해서 데이터베이스에 대한 네트워크 액세스를 통제
	- 특정 포트, IP, 보안 그룹을 허용하거나 차단할 수 있음
-   RDS와 Aurora에는 SSH 액세스가 없음
	- 관리형 서비스이기 때문
	- AWS의 RDS 커스텀 서비스를 사용한다면 예외
- 감사 로그가 있어서 시간에 따라 RDS 및 Aurora에서 어떤 쿼리가 생성되고 있고, 데이터베이스를 확인하려면 감사 로그 작성을 활성화하면 됨
- 로그는 시간이 지나면 자동으로 삭제되며 장기간 보관하고 싶다면 AWS에 있는 CloudWatch Logs라는 전용 서비스로 전송해야 함
### RDS Proxy
- VPC 내에 RDS 데이터베이스를 배포할 수 있는데 완전 관리형 RDS 데이터베이스 프록시도 배포할 수 있음
- Amazon RDS 프록시를 사용하면 애플리케이션이 데이터베이스 내에서 데이터베이스 연결 풀을 형성하고 공유할 수 있음
- 애플리케이션을 RDS 데이터베이스 인스턴스에 일일이 연결하는 대신 프록시에 연결하면 프록시가 하나의 풀에 연결을 모아 RDS 데이터베이스 인스턴스로 가는 연결이 줄어듦
- RDS 데이터베이스 인스턴스에 연결이 많은 경우 CPU와 RAM 등 데이터베이스 리소스의 부담을 줄여 데이터베이스 효율성을 향상시킬 수 있고, 데이터베이스에 개방된 연결과 시간초과를 최소화할 수 있기 때문
- RDS 프록시는 완전한 서버리스로 오토 스케일링이 가능해 용량을 관리할 필요가 없고 가용성이 높음
- 다중 AZ도 지원
- RDS 데이터베이스 인스턴스에 장애 조치가 발생하면 기본 인스턴스가 아니라 대기 인스턴스로 실행되며 RDS 프록시 덕분에 RDS와 Aurora의 장애 조치 시간을 66%까지 줄일 수 있음
- 메인 RDS 데이터베이스 인스턴스에 애플리케이션을 모두 연결하고, 장애 조치를 각자 처리하게 하는 대신 장애 조치와 무관한 RDS 프록시에 연결
- RDS 프록시가 장애 조치가 발생한 RDS 데이터베이스 인스턴스를 처리하므로 장애 조치 시간이 개선
- RDS 프록시는 MySQL, PostgreSQL MariaDB용 RDS를 지원하며 MySQL, PostgreSQL용 Aurora를 지원
- 애플리케이션의 코드를 변경하지 않아도 되고, RDS 데이터베이스 인스턴스나 Aurora 데이터베이스에 연결하는 대신 RDS 프록시에 연결하기만 하면 됨
- 데이터베이스에 IAM 인증을 강제함으로써 IAM 인증을 통해서만 RDS 데이터베이스 인스턴스에 연결하도록 할 수 있음
- **데이터베이스에 IAM 인증을 강제하고 싶다면 RDS 프록시를 사용**
- RDS는 퍼블릭 액세스가 절대로 불가능 -> VPC 내에서만 액세스할 수 있음
- 코드 조각을 실행하는 Lambda 함수를 이용하면 더욱 용이
- RDS 데이터베이스 인스턴스에 수만 개의 Lambda 함수가 순식간에 발생했다 사라지며 연결을 개방한다면 부하가 높음
- RDS 프록시를 사용해서 Lambda 함수의 연결 풀을 생성하면 Lambda 함수가 RDS 프록시를 오버로드
- RDS 프록시가 풀을 생성하면 RDS 데이터베이스 인스턴스 연결이 줄어 문제가 해결
- **RDS 프록시를 사용하면 RDS 데이터베이스 인스턴스의 연결을 최소화할 수 있고, 장애 조치 시간을 최대 66%까지 감소시킬 수 있음**
- 데이터베이스에 IAM 인증을 강제하는 데 사용되고, 자격 증명은 Secrets Manager 서비스에 안전히 저장됨
### ElastiCache 개요
- RDS가 관계형 데이터베이스를 관리하는 것과 같은 방식
- ElastiCache는 캐싱 기술인 Redis 또는 Memcached를 관리할 수 있도록 도와줌
- 캐시는 매우 높은 성능과 짧은 지연 시간을 가진 `인메모리 데이터베이스`
- 캐시는 읽기 집약적인 워크로드에서 데이터베이스의 로드를 줄여줌
- 쿼리는 캐시에 저장되므로, 매번 데이터베이스를 쿼리하지 않아도 됨
- 캐시만 사용하여 쿼리의 결과를 검색할 수 있음
-  애플리케이션의 상태를 Amazon ElastiCache에 저장해서 애플리케이션을 상태 비저장형으로 할 수 있게 도와줌
- AWS는 데이터베이스의 운영 체제를 유지 관리할 수 있음
- 패치, 최적화, 설정, 구성, 모니터링, 장애 복구, 백업 등
- Amazon ElastiCache를 사용하는 경우, 애플리케이션의 코드를 많이 바꿔야 함
- ElastiCache를 사용하기 위한 아키텍처
	- Amazon ElasticCache, RDS 데이터베이스, 애플리케이션이 있다고 가정, 애플리케이션은 ElastiCache를 쿼리, 쿼리가 이미 발생했는지 확인하기 위해, 이미 발생하여 ElastiCache에 저장되어 있다면, `캐시 히트`라고 함
	- 쿼리를 수행하기 위해 데이터베이스로 이동하는 시간이 절약
	- 캐시 미스가 발생하면, 데이터베이스에서 데이터를 가져와야 함
	- 다른 애플리케이션이나 다른 인스턴스에서 같은 쿼리가 발생하면 데이터를 캐시에 다시 쓸 수 있음, 다음에 동일한 쿼리가 일어나면 캐시 히트가 됨
	- RDS 데이터베이스의 로드를 줄이는 데 도움이 됨
- 캐시 무효화 전략
	- 가장 최신 캐시만 사용되어야 하기 때문에
	- 아키텍처는 사용자 세션을 저장, 애플리케이션을 상태 비저장으로 만들기 위해
	- 즉, 사용자가 어떤 애플리케이션에 로그인하면, 애플리케이션이 세션 데이터를 Amazon ElastiCache에 씀
	- 사용자가 애플리케이션의 다른 인스턴스로 리디렉션되면, 애플리케이션은 그 세션의 세션 캐시를 Amazon ElastiCache에서 직접 검색할 수 있으므로, 사용자는 여전히 로그인 상태
	- 사용자의 세션 데이터를 Amazon ElastiCache에 기록해서 애플리케이션을 상태 비저장형으로 만드는 것
- Redis vs Memcached
	- Redis의 경우, 자동 장애 조치 기능이 있는 다중 AZ가 있고, 읽기 복제본이 있음
	- 읽기를 확장하고 고가용성
	- RDS와 매우 유사
	- AOF 지속성을 이용한 데이터 내구성이 있고, 백업 및 복원 기능이 있음
	- Redis는 `데이터 내구성`
	- 기능 면에서는 **캐시로서, 세트 및 정렬된 세트를 지원**
	- Redis를 복제되는 캐시
- Memcached는 데이터 분할을 위해 멀티 노드를 사용 -> sharding
	- 고가용성이 없고 복제가 일어나지 않으며 영구 캐시가 아니며 백업 및 복원도 없음
	- 멀티스레드 아키텍처
	- 데이터가 손실되어도 괜찮은 경우
- Redis는 고가용성, 백업, 읽기 복제본 등을 위해 존재, 반면 Memcached는 분산되어 있는 순수한 캐시
### Cache Security
- ElastiCache는 Redis에서만 IAM 인증을 지원하며, 나머지 경우에는 사용자 이름과 비밀번호를 사용
- ElastiCache에서 IAM 정책을 정의하면 AWS API 수준 보안에만 사용
- `Redis AUTH`이라는 Redis 내 보안을 통해 비밀번호와 토큰을 설정할 수 있음
- Redis 클러스터를 만들 때, 캐시에 추가 보안 수준을 제공 -> 보안그룹에 추가로
- SSL 전송 중 암호화도 지원
- Memcached는 `SASL 기반 승인`을 제공
- 예를 들어 EC2 인스턴스와 클라이언트가 있는 경우 Redis AUTH를 사용하여 Redis 클러스터에 연결할 수 있고, Redis 보안 그룹에 의해 보호됨, 또한 인플라이트 암호화를 사용하거나, 또는 Redis에서 IAM 인증을 활용할 수 있음
- ElastiCache에 데이터를 로드하는 3가지 패턴
	- 지연 로딩(lazy loading)
		- 모든 데이터가 캐시되고 데이터가 캐시에서 지체될 수 있음
		- Write Through는 데이터베이스에 데이터가 기록될 때마다 캐시에 데이터를 추가하거나 업데이트, 데이터가 지체되지 않음
		- ElastiCache를 앞서 살펴본 세션 스토어로 사용할 수 있음, 유지 시간 기능을 사용해 세션을 만료할 수 있음
		- 애플리케이션에 캐시 히트가 있는 경우, ElastiCache는 캐시에서 데이터를 가져옴
		- 캐시 미스의 경우에는 데이터베이스에서 읽고 캐시에 쓰게 됨
		- 캐시 히트가 없는 경우에만 데이터를 Amazon ElastiCache에 로드하기 때문
- Redis의 사용 사례
	- 게이밍 리더보드 만들기에 관한 것으로 순위를 지정하고 싶음
	- Redis에는 `정렬된 세트`라는 게 있음, 고유성과 요소 순서를 모두 보장
	- 요소가 추가될 때마다, 실시간으로 순위를 매긴 다음 올바른 순서로 추가됨
	- Redis 클러스터가 있는 경우 실시간 리더보드를 만들 수 있음
	- 클라이언트가 Redis를 사용하여 Amazon elasticache와 대화할 때 이 실시간 리더보드에 액세스할 수 있으며, 애플리케이션 측에서 이 기능을 프로그래밍할 필요가 없음
	- **정렬된 세트와 함께 Redis를 활용하여 실시간 리더보드에 액세스할 수 있음**
### 포트 목록
-  **HTTPS - 443번 포트**
- **PostgreSQL - 5432번 포트**
- FTP: 21
- SSH: 22
- SFTP: 22 (SSH와 같음)
- HTTP: 80
- HTTPS: 443
- MySQL: 3306
- Oracle RDS: 1521
- MSSQL Server: 1433
- MariaDB: 3306 (MySQL과 같음)
- Aurora: 5432 (PostgreSQL와 호환될 경우) 또는 3306 (MySQL과 호환될 경우)
