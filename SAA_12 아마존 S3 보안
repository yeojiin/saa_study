### S3 암호화 개요
- 객체 암호화
	- SSE(서버 측 암호화) 
		- SSE-S3: 기본 설정, S3에서 관리하는 키를 이용한 서버 측 암호화
			- AWS가 관리하는 키에 엑세스 할 수 없음
			- AES-256를 사용하기 때문에 헤더에 x-amz-server-side-encryption":"AES256 를 설정해야 함
			- S3 키와 보유한 객체를 매핑하는 방식으로 작동
		- SSE-KMS: KMS 키를 이용해 암호화 키를 관리
			- 직접 KMS에서 키 관리 가능
			- CloudTrail을 이용해 키 사용을 검사할 수 있음 -> 키를 사용한 사람이 로깅 가능
			- 헤더에 x-amz-server-side-encryption":"aws:kms 필요
			- S3버킷 처리량이 많고 모든게 KMS 키로 암호화된다면 스로틀링 활용 사례가 될 수 있음
		-  SSE-C: 고객이 제공한 키를 사용
			- AWS 외부에서 키가 관리됨
			- HTTPS를 사용해야하고 헤더에 키를 전송해야 함
	- Client-Side Encryption: 클라이언트 측의 모든 걸 암호화 한 후 S3에 업로드 함
		- 클라이언트 라이브러리를 활용해 쉽게 구현 가능
		- 클라이언트가 직접 데이터를 암호화한 다음에 Amazon S3에 전송한다는 개념
		- Amazon S3로부터 데이터를 받을 수 있고요, 그 다음으로 데이터의 복호화는 Amazon S3 외부의 클라이언트 측에서 이루어짐 
-  전송 중 암호화
	- SSL/TLS라고 함
	- 2개의 엔드포인트 존재: 암호화가 되지 않는 HTTP 엔드포인트가 있고, 전송 중 암호화가 제공되는 HTTPS 엔드포인트가 있음
	- SSE-C 타입의 메커니즘을 이용한다면 반드시 HTTPS 프로토콜을 사용해야 함
	- 버킷 정책을  사용해서 강제할 수 있음 -> aws:SecureTransport가 false이면 GetObject 작업 거부
### S3 기본 암호화
- 저장된 새로운 객체에 SSE-S3 암호화가 자동으로 적용되는데 SSE-KMS 같은 다른 기본 암호화로 변경할 수 있음
- 버킷 정책을 주어 원하는 암호화를 강제할 수 있고, 올바른 암호화 헤더가 없는 경우 S3 객체를 PUT하는 API의 호출을 거절할 수 있음
### CORS(cross-origin resource sharing)
- origin = scheme 체계(프로토콜) + host(도메인) + 포트
	- https://www.example.com
		- Https의 포트는 443
		- 프로토콜은 HTTP 자체
		- 도메인은 www.example.com
- 웹 브라우저 기반 보안 메커니즘으로 메인 오리진에 방문하는 동안 다른 오리진에 대한 요청을 허용하거나 거부함
- http://example.com/app1 과 http://example.com/app2 은 같은 오리진 -> 체계, 호스트, 포트가 동일할 때
- 다른 오리진을 요청할 때 CORS Headers를 사용해 요청을 허용하지 않으면 요청은 이행되지 않음 -> 엑세스 제어 허용 오리진 헤더(Access-Control-Alllow-Origin)
- 특정 오리진을 허용하거나 * 을 붙여 모든 오리진을 허용함
###  MFA Delete
- 멀티 팩터 인증, 사용자가 장치에서 코드를 생성하도록 강제함
- S3에서 중요한 작업을 하기 전 필수로 요청하는 경우가 많음
- 언제 사용?
	- **영구적으로 객체의 버전을 삭제**할 때
	- 버킷에서 버저닝을 중단할 때
- MFA Delete를 사용하려면 먼저 버킷에서 버저닝을 활성화 해야함
- 버킷 소유자, 즉 `루트 사용자`만 활성화하거나 비활성화 할 수 있음
### S3 엑세스 로그
- 감사 목적으로 S3 버킷에 대한 모든 액세스를 기록할 수 있음
- 어떤 계정에서든 S3로 보낸 모든 요청은 다른 S3버킷에 파일로 기록됨
- Amazon  Athena같은 데이터 분석 도구로 분석 할 수 있음
- 로깅 대상 버킷은 같은 AWS 리전에 존재해야 함
- 주의사항
	- **`로깅 버킷`을 `모니터링 하는 버킷`과 동일하게 설정하지 말 것** -> 동일하게 설정 시 로킹 루프가 생성되고 무한 반복되어 버킷의 크기가 증가함
### S3 사전 서명된 URL(Pre-signed URLs)
- S3 콘솔, CLI, SDK를 사용해 생성 가능한 URL
- URL에는 만료 기한이 있는데 S3 콘솔을 사용하면 최대 12시간, CLI는 16시간
- URL을 받는 사용자는 URL을 생성한 사용자의 GET, PUT 권한을 갖게됨
- S3 버킷의 파일을 외부 사용자가 액세스하고 싶을 때 public으로 두는게 아니라 미리 서명된 URL을 제공해서 액세스 가능하도록 
- 예시
	- 로그인한 사용자만 S3 버킷에서 프리미엄 비디오를 다운로드 가능할 때
	- 사용자 목록이 계속 변할 경우
	- 일시적으로 사용자가 S3 버킷의 특정한 위치에 파일을 업로드하도록 허용할 수 있음, 버킷은 비공개로 유지
### S3 잠금 정책 및 Glacier Vault Lock
- WORM(Write Once Read Many) 모델을 채용하기 위해 Glacier 볼트를 잠그는 것
- 객체를 가져와 Glacier 볼트에 넣고 잠궈 수정하거나 삭제할 수 없도록 함
- 볼트를 생성하고 잠금 정책을 설정함 -> 정책 설정 후에는 누구도 변경하거나 삭제할 수 없음
- 보안에 용이
- AWS서비스를 삭제해도 해당 객체는 삭제 불가
-  S3 객체 잠금(버저닝 필수)
	- S3 객체 잠금을  활성화 하려면 `버저닝을 활성화` 해야함
	- WORM모델을 사용할 수 있음
	- 버킷 내의 모든 객체에 각각 적용할 수 있는 잠금
	- 단일 객체 잠금이 가능함 -> 전체 버킷에 잠금이 아님
	- **특정 객체 버전이 특정 시간 동안 삭제되는 걸 차단할 수 있음**
	- 보전 모드
		- 규정 준수 모드
			- 누구도 객체를 수정이나 삭제할 수 없음
		- 거버넌스 보존(Govermace Retention) 모드
			- IAM으로 권한을 부여받은 관리자는 수정하거나 삭제가 가능함
	- 보존 모드 두가지 모드 보존 기간을 설정해야함
	- 법적 보존(Legal Hold): S3내 모든 버킷이 영원히 존재함
		- PutObjectLegalHold 권한으로 법적 보전을 주고 법적 보존 기간이 끝나면 같은 권한으로 법적 보존을 삭제할 수 있음
		- 유연한 모드 -> 필요할 때만 활성화
		- 객체 버전을 무기한 덮어쓰거나 삭제할 수 없도록 방지하고 수동으로 삭제할 수 있는 기능만 제공할고 싶을 때
### S3 엑세스 포인트
- 시간이 지날 수록 S3가 복잡해질 수 있다
- 엑세스 포인트를 만들어서 관리
	- ex)  재무 엑세스 포인트를 만들기
		-  재무 관련 데이터들이(S3에 있는)  있고, S3 버킷 정책과 같은 모습, /finance라는 접두어에 읽기와 쓰기 엑세스 권한을 부여함 -> 재무 관련 사용자들만 해당 엑세스 포인트에 접근할 수 있게하면 영업관련 내용은 접근하지 못하게 할 수 있음
	- ex) Sales 엑세스 포인트 만들기
		- /sales라는 접두어에 읽기/쓰기 권한을 부여
	- ex) Analytice 엑세스 포인트 만들기
		- 읽기 전용 정책을 실행
		- 재무와 sales를 넣으면 둘다 접근 가능
 - 엑세스 포인트는 S3 버킷의 보안 관리를 간소호함
- 각각의 엑세스 포인트는 **각각의 DNS 명을 갖게 되어** 특정 사용자만 접근 가능하게 할 수 있음
- 엑세스 포인트는 인터넷 오리진에 연결되거나 프라이빗 트래픽의 경우에 VPC 오리진에 연결되도록 할 수 있음
-  VPC의 EC2 인스턴스는 인터넷을 통하지 않고 VPC엑세스 포인트와 VPC오리진을 통해 S3 버킷에 엑세스 할 수 있음
- 이 VPC 오리진에 엑세스 하기 위해 엑세스 포인트에 엑세스하기 위한 VPC 엔드포인트라는걸 만들어야 함 -> 해당 VPC 엔트포인트로 엑세스 포인트인 VPC오리진에 접근 가능함
- EC2 인스턴스 -> VPC 엔드포인트 -> 엑세스포인트(VPC 오리진) -> S3 버킷
- VPC엔드포인트에는 정책이 있고, 정책은 타깃 버킷과 액세스 포인트에 대한 엑세스를 허용해야 함
- VPC 엔트포이트 정책은 EC2 인스턴스가  S3의 액세스 포인트와 S3 버킷에 모둔 엑세스 가능하게 해줌
### S3 오브젝트 람다
- S3버킷이 있는데 호출자 어플리케이션이 객체를 받기 전에 해당 객체를 수정하려고 할 때
- 버킷을 복제해 각 객체의 다른 버전을 갖는 대신에 S3 객체 람다를 사용할 수 있음 -> 엑세스 포인트가 필요함
- PII 데이터(개인식별 정보)를 삭제하는 경우, 데이터 형식을 XML에서 JSON으로 변환하는 경우,  즉석에서 이미지 크기를 조정하거나 워터마크를 추가하는 등의 경우에 사용됨
- 예시
	- 한 전자 상거래 업체는 고객 데이터와 주문 데이터를 S3 버킷에 저장하고 있습니다. 이 업체의 CEO가 고객 목록과 각 고객에게서 발생한 수익을 보여주는 보고서를 생성하려고 합니다. S3 버킷에 있는 파일에 저장된 고객 데이터 중에는 보고서에 노출하면 안 되는 민감 정보가 포함되어 있습니다. 민감 정보를 노출하지 않고 보고서를 생성하려면 어떤 방법을 사용해야 합니까?
	- S3 객체 Lambda를 사용해 보고서 생성 어플리케이션으로 객체를 반환하기 전에 객체를 변경한다
