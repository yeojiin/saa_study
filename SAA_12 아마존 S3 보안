### S3 암호화 개요
- SSE 
	- SSE-S3: 기본 설정 가능, S3에서 관리하는 키
	- SSE-KMS: KMS 키를 이용해 암호화 키를 관리
	- SSE-C: 고객이 제공한 키를 사용
- Client-Side Encryption: 클라이언트 측의 모든 걸 암호화 한 후 S3에 업로드 함

### SSE-S3
- AWS가 처리하고 관리하고 소유한 키를 이용해 암호화 함 -> AES-256사용
- 해당 키에 액세스 불가
- "x-amz-server-side-encryption":"AES256" 헤더가 필요
- 기본 값으로 활성화 되어 있음

### SSE-KMS
- AWS와 S3 서비스가 보유한 키에 의존하지 않고, KMS 서비스를 이용해 직접 키를 관리함
- 키를 직접 생성하고 관리하고 CloudTrail 로 관리도 가능
- "x-amz-server-side-encryption":"aws:kms" 헤더가 필요
- 키와 객체 각각 접근에 대한 키가 필요하기 때문에 보안이 강화됨
- 제약사항
	- KMS API로 키를 생성하고
	- Decrypt API를 사용해 복호화를 해야함

### SSE-C
- AWS외부에서 키가 관리되지만 서버측 암호화임 -> 키를 AWS로 그대로 전당하기 때문
- 사용 후 폐기됨, 반드시 HTTPS를 사용해야 함
- 모든 요청에 HTTP 헤더의 일부로 키를 전달해야 함

### Client-Side 암호화
- 클라이언트 라이브러리를 활용해 쉽게 구현 가능
- 클라이언트가 직접 데이터를 암호화한 다음에 Amazon S3에 전송한다는 개념
- Amazon S3로부터 데이터를 받을 수 있고요, 그 다음으로 데이터의 복호화는 Amazon S3 외부의 클라이언트 측에서 이루어짐

### 전송 중 암호화
- SSL/TLS라고 함
- 2개의 엔드포인트 존재: 암호화가 되지 않는 HTTP 엔드포인트가 있고, 전송 중 암호화가 제공되는 HTTPS 엔드포인트가 있음
- SSE-C 타입의 메커니즘을 이용한다면 반드시 HTTPS 프로토콜을 사용해야 함
- 버킷 정책을  사용해서 강제할 수 있음

### S3 기본 암호화
- 저장된 새로운 객체에 SSE-S3 암호화가 자동으로 적용되는데 SSE-KMS 같은 다른 기본 암호화로 변경할 수 있음
- 버킷 정책을 주어 원하는 암호화를 강제할 수 있음

### CORS(cross-origin resource sharing)
- origin = scheme 체계(프로토콜) + host(도메인) + 포트
	- https://www.example.com
		- Https의 포트는 443
		- 프로토콜은 HTTP 자체
		- 도메인은 www.example.com
- 웹 브라우저 기반 보안 메커니즘으로 메인 오리진에 방문하는 동안 다른 오리진에 대한 요청을 허용하거나 거부함
- http://example.com/app1 과 http://example.com/app2 은 같은 오리진 -> 체계, 호스트, 포트가 동일할 때
- 다른 오리진을 요청할 때 CORS Headers를 달지 않으면 허용되지 않음
- 특정 오리진을 허용하거나 * 을 붙여 모든 오리진을 허용함

###  MFA Delete
- 멀티 팩터 인증, 사용자가 장치에서 코드를 생성하도록 강제함
- S3에서 중요한 작업을 하기 전 필수로 요청하는 경우가 많음
- 언제 사용?
	- 영구적으로 객체의 버전을 삭제할 때
	- 버킷에서 버저닝을 중단할 때
- MFA Delete를 사용하려면 먼저 버킷에서 버저닝을 활성화 해야함
- 버킷 소유자, 즉 루트 사용자만 활성화하거나 비활성화 할 수 있음

### S3 엑세스 로그
- 감사 목적으로 S3 버킷에 대한 모든 액세스를 기록할 수 있음
- 어떤 계정에서든 S3로 보낸 모든 요청은 다른 S3버킷에 파일로 기록됨
- Amazon  Athena같은 데이터 분석 도구로 분석 할 수 있음
- 로깅 대상 버킷은 같은 AWS 리전에 존재해야 함
- 주의사항
	- **로깅 버킥을 모니터링 하는 버킷과 동일하게 설정하지 말 것** -> 동일하게 설정 시 로킹 루프가 생성되고 무한 반복되어 버킷의 크기가 증가함


### S3 사전 서명된 URL
- S3 콘솔, CLI, SDK를 사용해 생성 가능한 URL
- URL에는 만료 기한이 있는데 S3 콘솔을 사용하면 최대 12시간, CLI는 16시간
- URL을 받는 사용자는 URL을 생성한 사용자의 GET, PUT 권한을 갖게됨
- S3 버킷의 파일을 외부 사용자가 액세스하고 싶을 때 public으로 두는게 아니라 미리 서명된 URL을 제공해서 액세스 가능하도록 
- 예시
	- 로그인한 사용자만 S3 버킷에서 프리미엄 비디오를 다운로드 가능할 때
	- 사용자 목록이 계속 변할 경우
	- 일시적으로 사용자가 S3 버킷의 특정한 위치에 파일을 업로드하도록 허용할 수 있음, 버킷은 비공개로 유지

### S3 잠금 정책 및 Glacier 볼트 잠금
- WORM(Write Once Read Many) 모델을 채용하기 위해 Glacier 볼트를 잠그는 것
- 객체를 가져와 Glacier 볼트에 넣고 잠궈 수정하거나 삭제할 수 없도록 함
- 볼트를 생성하고 잠금 정책을 설정함 -> 정책 설정 후에는 누구도 변경하거나 삭제할 수 없음
- 보안에 용이
- AWS서비스를 삭제해도 해당 객체는 삭제 불가

### S3 객체 잠금(버저닝 필수)
- S3 객체 잠금을  활성화 하려면 버저닝을 활성화 해야함
- WORM모델을 사용할 수 있음
- 버킷 내의 모든 객체에 각각 적용할 수 있는 잠금
- 단일 객체 잠금이 가능함
- 특정 객체 버전이 특정 시간 동안 삭제되는 걸 차단할 수 있음
- 보전 모드
	- 규정 준수 모드
		- 누구도 객체를 수정이나 삭제할 수 없음
	- 거버넌스 보존(Retention) 모드
		- IAM으로 권한을 부여받은 관리자는 수정하거나 삭제가 가능함
- 보존 모드 두가지 모드 보존 기간을 설정해야함
- 법적 보존: S3내 모든 버킷이 영원히 존재함
	- PutObjectLegalHold 권한으로 법적 보전을 주고 법적 보존 기간이 끝나면 같은 권한으로 법적 보존을 삭제할 수 있음
	- 유연한 모드 -> 필요할 때만 활성화

### S3 엑세스 포인트
- 시간이 지날 수록 S3가 복잡해질 수 있다
- 엑세스 포인트를 만들어서 관리
	- ex) - 재무 엑세스 포인트를 만들기
					-  재무 관련 데이터들이(S3에 있는)  있고, S3 버킷 정책과 같은 모습, /finance라는 접두어에 읽기와 쓰기 엑세스 권한을 부여함 -> 재무 관련 사용자들만 해당 엑세스 포인트에 접근할 수 있게하면 영업관련 내용은 접근하지 못하게 할 수 있음
	 ![[Pasted image 20231118204007.png]]
- 엑세스 포인트느 S3 버킷의 보안 관리를 간소호함
- 각각의 엑세스 포인트는 **각각의 DNS 명을 갖게 되어** 특정 사용자만 접근 가능하게 할 수 있음
- 엑세스 포인트는 인터넷 오리진에 연결되거나 프라이빗 트래픽의 경우에 VPC 오리진에 연결되도록 할 수 있음
-  VPC의 EC2 인스턴스는 인터넷을 통하지 않고 VPC엑세스 포인트와 VPC오리진을 통해 S3 버킷에 엑세스 할 수 있음
- 이 VPC 오리진에 엑세스 하기 위해 엑세스 포인트에 엑세스하기 위한 VPC 엔드포인트라는걸 만들어야 함 -> 해당 VPC 엔트포인트로 엑세스 포인트인 VPC오리진에 접근 가능함
- EC2 인스턴스 -> VPC 엔드포인트 -> 엑세스포인트(VPC 오리진) -> S3 버킷
- VPC엔드포인트에는 정책이 있고, 정책은 타깃 버킷과 액세스 포인트에 대한 엑세스를 허용해야 함
- VPC 엔트포이트 정책은 EC2 인스턴스가  S3의 액세스 포인트와 S3 버킷에 모둔 엑세스 가능하게 해줌

### S3 오브젝트 람다
- S3버킷이 있는데 호출자 어플리케이션이 객체를 받기 전에 해당 객체를 수정하려고 할 때
- 버킷을 복제해 각 객체의 다른 버전을 갖는 대신에 S3 객체 람다를 사용할 수 있음 -> 엑세스 포인트가 필요함
- PII 데이터(개인식별 정보)를 삭제하는 경우, 데이터 형식을 XML에서 JSON으로 변환하는 경우,  즉석에서 이미지 크기를 조정하거나 워터마크를 추가하는 등의 경우에 사용됨
